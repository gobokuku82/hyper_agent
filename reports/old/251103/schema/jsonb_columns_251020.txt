================================================================================
JSONB 컬럼 상세 정보 - Phase 0.1 Step 4
생성일시: 2025-10-20
데이터베이스: real_estate (PostgreSQL)
================================================================================

쿼리:
SELECT
    c.table_name,
    c.column_name,
    c.data_type,
    c.is_nullable,
    c.column_default,
    pg_catalog.col_description(pgc.oid, c.ordinal_position::int) as column_comment
FROM information_schema.columns c
JOIN pg_catalog.pg_class pgc ON c.table_name = pgc.relname
WHERE c.table_schema = 'public'
  AND c.data_type = 'jsonb'
ORDER BY c.table_name, c.column_name;

결과:
table_name   |   column_name   | data_type | is_nullable | column_default |              column_comment
---------------+-----------------+-----------+-------------+----------------+------------------------------------------
 chat_messages | structured_data | jsonb     | YES         |                | 구조화된 답변 데이터 (sections, metadata)
 chat_sessions | metadata        | jsonb     | YES         |                | 추가 메타데이터
 checkpoints   | checkpoint      | jsonb     | NO          |                |
 checkpoints   | metadata        | jsonb     | NO          | '{}'::jsonb    |
(4개 행)

================================================================================
상세 분석
================================================================================

1. chat_messages.structured_data (JSONB)
   ----------------------------------------
   - Nullable: YES (NULL 허용)
   - Default: 없음
   - Comment: "구조화된 답변 데이터 (sections, metadata)"
   - 용도:
     * 답변의 sections (섹션별 구조화된 내용)
     * 답변의 metadata (메타데이터)
   - Phase 1 활용:
     * 현재 용도 그대로 유지
     * Memory 저장용으로는 사용하지 않음

2. chat_sessions.metadata (JSONB)
   ----------------------------------------
   - Nullable: YES (NULL 허용)
   - Default: 없음
   - Comment: "추가 메타데이터"
   - 용도:
     * 세션별 추가 정보 저장용 범용 컬럼
   - ⭐ Phase 1 활용 계획:
     * SimpleMemoryService에서 conversation_summary 저장
     * 구조 예시:
       {
         "conversation_summary": "사용자가 강남 아파트 매매 문의...",
         "last_updated": "2025-10-20T10:30:00Z",
         "summary_count": 3
       }
   - 장점:
     * 이미 존재하는 컬럼 활용 (마이그레이션 불필요)
     * NULL 허용으로 기존 데이터 영향 없음
     * JSONB 타입으로 유연한 구조 저장 가능

3. checkpoints.checkpoint (JSONB)
   ----------------------------------------
   - Nullable: NO (NOT NULL)
   - Default: 없음
   - Comment: 없음
   - 용도: LangGraph 체크포인트 데이터 저장
   - 참고: Memory Service와 무관

4. checkpoints.metadata (JSONB)
   ----------------------------------------
   - Nullable: NO (NOT NULL)
   - Default: '{}'::jsonb (빈 JSON 객체)
   - Comment: 없음
   - 용도: LangGraph 체크포인트 메타데이터
   - 참고: Memory Service와 무관

================================================================================
Phase 1 구현 전략 확정
================================================================================

✅ 사용할 JSONB 컬럼: chat_sessions.metadata

이유:
1. NULL 허용으로 기존 세션에 영향 없음
2. "추가 메타데이터" 목적으로 설계되어 용도에 부합
3. 별도 마이그레이션 불필요
4. JSONB GIN 인덱스 추가로 검색 성능 향상 가능 (Phase 2에서 고려)

❌ 사용하지 않을 컬럼: chat_messages.structured_data

이유:
1. 이미 "답변 데이터" 용도로 사용 중
2. Memory는 세션 레벨, structured_data는 메시지 레벨
3. 용도 혼재 방지

================================================================================
SimpleMemoryService 구현 방향
================================================================================

1. save_conversation 메서드:
   ```python
   async def save_conversation(
       self,
       user_id: str,
       session_id: str,
       messages: List[dict],
       summary: str
   ) -> None:
       # chat_sessions의 해당 session_id 레코드 찾기
       session = await self.db.execute(
           select(ChatSession).where(
               ChatSession.session_id == session_id,
               ChatSession.user_id == user_id
           )
       )
       session = session.scalar_one_or_none()

       if session:
           # metadata JSONB 업데이트
           if session.session_metadata is None:
               session.session_metadata = {}

           session.session_metadata["conversation_summary"] = summary
           session.session_metadata["last_updated"] = datetime.now().isoformat()

           flag_modified(session, "session_metadata")
           await self.db.commit()
   ```

2. load_recent_memories 메서드:
   ```python
   async def load_recent_memories(
       self,
       user_id: str,
       limit: int = 5,
       relevance_filter: str = "ALL",
       session_id: Optional[str] = None  # ⭐ 추가!
   ) -> List[dict]:
       query = select(ChatSession).where(
           ChatSession.user_id == user_id,
           ChatSession.session_metadata.isnot(None)
       )

       # 현재 세션 제외 (진행 중인 세션의 불완전한 데이터 제외)
       if session_id:
           query = query.where(ChatSession.session_id != session_id)

       query = query.order_by(ChatSession.updated_at.desc()).limit(limit)

       result = await self.db.execute(query)
       sessions = result.scalars().all()

       memories = []
       for session in sessions:
           if session.session_metadata and "conversation_summary" in session.session_metadata:
               memories.append({
                   "session_id": session.session_id,
                   "summary": session.session_metadata["conversation_summary"],
                   "timestamp": session.updated_at.isoformat()
               })

       return memories
   ```

================================================================================
JSONB 인덱스 고려사항 (Phase 2)
================================================================================

현재 chat_sessions.metadata에 인덱스가 있는지 확인 필요.
Phase 2에서 검색 성능 향상을 위해 GIN 인덱스 추가 고려:

```sql
CREATE INDEX idx_chat_sessions_metadata_gin
ON chat_sessions USING GIN (metadata);
```

이는 Phase 0.1 Step 5 (Foreign Key 확인) 후 Phase 0.2에서 확인할 예정.

================================================================================
다음 단계 (Step 5)
================================================================================

Foreign Key 관계 확인:
- chat_sessions.user_id → users.id
- chat_messages.session_id → chat_sessions.session_id
- CASCADE 설정 확인
