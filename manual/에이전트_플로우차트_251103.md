# 에이전트 플로우차트

**작성일**: 2025-11-03
**버전**: 0.4.0

---

## 목차

1. [Supervisor Pattern 개요](#supervisor-pattern-개요)
2. [전체 에이전트 플로우](#전체-에이전트-플로우)
3. [개별 노드 상세](#개별-노드-상세)
4. [에이전트 라우팅 로직](#에이전트-라우팅-로직)
5. [상태 전파](#상태-전파)

---

## Supervisor Pattern 개요

Supervisor Pattern은 LangGraph 1.0에서 제공하는 멀티 에이전트 오케스트레이션 패턴입니다.

### 핵심 개념

- **Supervisor**: 전체 워크플로우를 조율하는 중앙 제어 노드
- **Worker Agents**: 특정 작업을 수행하는 전문 에이전트
- **StateGraph**: 상태 기반 워크플로우 관리
- **Checkpoint**: 각 단계마다 상태 저장

---

## 전체 에이전트 플로우

```mermaid
graph TB
    Start([사용자 입력]) --> Intent[Intent Understanding Node]

    Intent -->|의도 분석 완료| Planning[Planning Node]

    Planning -->|계획 수립 완료| Router[Router Node]

    Router --> RouterLogic{라우팅 로직}

    RouterLogic -->|검색 필요| SearchAgent[Search Agent]
    RouterLogic -->|웹 크롤링 필요| WebAgent[Web Agent]
    RouterLogic -->|계약서 작성| ContractAgent[Contract Agent]
    RouterLogic -->|코드 생성| CodeAgent[Code Agent]
    RouterLogic -->|데이터 분석| DataAgent[Data Agent]

    SearchAgent --> AgentComplete{모든 단계<br/>완료?}
    WebAgent --> AgentComplete
    ContractAgent --> AgentComplete
    CodeAgent --> AgentComplete
    DataAgent --> AgentComplete

    AgentComplete -->|No| Router
    AgentComplete -->|Yes| Aggregator[Aggregator Node]

    Aggregator --> Final[최종 응답 생성]

    Final --> End([종료])

    style Intent fill:#e1f5e1
    style Planning fill:#e1f5e1
    style Router fill:#fff4e1
    style SearchAgent fill:#e1e5ff
    style WebAgent fill:#e1e5ff
    style ContractAgent fill:#e1e5ff
    style CodeAgent fill:#e1e5ff
    style DataAgent fill:#e1e5ff
    style Aggregator fill:#ffe1f0
    style Final fill:#ffe1e1
```

---

## 개별 노드 상세

### 1. Intent Understanding Node

**목적**: 사용자의 의도를 분석하고 카테고리 분류

```mermaid
graph TB
    Start([사용자 메시지]) --> Extract[메시지 추출]

    Extract --> BuildPrompt[Intent Prompt 구성]

    BuildPrompt --> CallLLM[LLM 호출<br/>GPT-4]

    CallLLM --> ParseResponse[응답 파싱]

    ParseResponse --> ExtractIntent[의도 정보 추출]

    ExtractIntent --> Categories{카테고리}

    Categories -->|search| SetSearch[category: search]
    Categories -->|web| SetWeb[category: web]
    Categories -->|contract| SetContract[category: contract]
    Categories -->|code| SetCode[category: code]
    Categories -->|data| SetData[category: data]
    Categories -->|general| SetGeneral[category: general]

    SetSearch --> SaveState
    SetWeb --> SaveState
    SetContract --> SaveState
    SetCode --> SaveState
    SetData --> SaveState
    SetGeneral --> SaveState

    SaveState[상태 업데이트<br/>user_intent] --> Checkpoint[Checkpoint 저장]

    Checkpoint --> End([다음 노드로])

    style CallLLM fill:#ffe1e1
    style Checkpoint fill:#e1f0ff
```

**상태 업데이트**:
```python
{
    "user_intent": {
        "category": "contract",
        "description": "계약서 작성 요청",
        "key_entities": ["계약서", "작성"],
        "complexity": "medium"
    }
}
```

---

### 2. Planning Node

**목적**: 실행 계획 수립 및 에이전트 할당

```mermaid
graph TB
    Start([이전 상태]) --> LoadIntent[user_intent 로드]

    LoadIntent --> BuildPlanPrompt[Planning Prompt 구성]

    BuildPlanPrompt --> CallLLM[LLM 호출<br/>GPT-4]

    CallLLM --> ParsePlan[계획 파싱]

    ParsePlan --> ExtractSteps[단계 추출]

    ExtractSteps --> AssignAgents[에이전트 할당]

    AssignAgents --> EstimateTime[시간 예측]

    EstimateTime --> CreatePlan[Plan 객체 생성]

    CreatePlan --> SaveState[상태 업데이트<br/>plan, current_step]

    SaveState --> SetFlags[is_planning: false<br/>is_executing: true]

    SetFlags --> Checkpoint[Checkpoint 저장]

    Checkpoint --> End([다음 노드로])

    style CallLLM fill:#ffe1e1
    style Checkpoint fill:#e1f0ff
```

**상태 업데이트**:
```python
{
    "plan": {
        "total_steps": 3,
        "steps": [
            {
                "step": 1,
                "agent": "contract",
                "task": "계약서 초안 작성",
                "estimated_time": "2분"
            },
            {
                "step": 2,
                "agent": "hitl",
                "task": "사용자 승인",
                "estimated_time": "5분"
            },
            {
                "step": 3,
                "agent": "contract",
                "task": "최종 계약서 생성",
                "estimated_time": "1분"
            }
        ]
    },
    "current_step": 0,
    "is_planning": False,
    "is_executing": True
}
```

---

### 3. Router Node

**목적**: 현재 단계에 맞는 에이전트 선택 및 HITL 체크

```mermaid
graph TB
    Start([이전 상태]) --> LoadPlan[plan, current_step 로드]

    LoadPlan --> GetCurrentStep[현재 단계 정보 가져오기]

    GetCurrentStep --> CheckHITL{HITL<br/>단계?}

    CheckHITL -->|Yes| CheckWaiting{이미<br/>대기 중?}

    CheckWaiting -->|Yes| Skip[HITL 이미 처리됨]
    CheckWaiting -->|No| SetWaitingFlag[is_waiting_human: true]

    SetWaitingFlag --> Interrupt[interrupt 호출]

    Interrupt --> SaveHITL[HITL 상태 저장]

    SaveHITL --> WaitEnd([사용자 대기])

    CheckHITL -->|No| SelectAgent{에이전트<br/>선택}

    SelectAgent -->|search| RouteSearch[Search Agent로]
    SelectAgent -->|web| RouteWeb[Web Agent로]
    SelectAgent -->|contract| RouteContract[Contract Agent로]
    SelectAgent -->|code| RouteCode[Code Agent로]
    SelectAgent -->|data| RouteData[Data Agent로]

    Skip --> SelectAgent

    RouteSearch --> End
    RouteWeb --> End
    RouteContract --> End
    RouteCode --> End
    RouteData --> End

    End([선택된 에이전트로])

    style Interrupt fill:#ffe1e1
    style SaveHITL fill:#e1f0ff
```

**라우팅 로직**:
```python
def route_to_agent(state):
    plan = state["plan"]
    current_step = state["current_step"]
    step_info = plan["steps"][current_step]
    agent_name = step_info["agent"]

    # HITL 체크
    if agent_name == "hitl":
        if not state.get("is_waiting_human"):
            state["is_waiting_human"] = True
            interrupt("HITL 승인 필요")

    # 에이전트 라우팅
    return agent_name  # "search", "web", "contract", etc.
```

---

### 4. Worker Agents

#### Search Agent

```mermaid
graph TB
    Start([Router에서]) --> LoadTask[작업 정보 로드]

    LoadTask --> BuildQuery[검색 쿼리 구성]

    BuildQuery --> CallSearch[검색 API 호출]

    CallSearch --> ParseResults[결과 파싱]

    ParseResults --> Summarize[LLM으로 요약]

    Summarize --> SaveResult[결과 저장]

    SaveResult --> IncrementStep[current_step++]

    IncrementStep --> Checkpoint[Checkpoint 저장]

    Checkpoint --> End([Router로 복귀])

    style CallSearch fill:#ffe1e1
    style Summarize fill:#ffe1e1
    style Checkpoint fill:#e1f0ff
```

#### Web Agent

```mermaid
graph TB
    Start([Router에서]) --> LoadTask[작업 정보 로드]

    LoadTask --> ExtractURL[URL 추출]

    ExtractURL --> FetchPage[웹 페이지 가져오기]

    FetchPage --> ParseHTML[HTML 파싱]

    ParseHTML --> ExtractContent[콘텐츠 추출]

    ExtractContent --> LLMProcess[LLM으로 처리]

    LLMProcess --> SaveResult[결과 저장]

    SaveResult --> IncrementStep[current_step++]

    IncrementStep --> Checkpoint[Checkpoint 저장]

    Checkpoint --> End([Router로 복귀])

    style FetchPage fill:#ffe1e1
    style LLMProcess fill:#ffe1e1
    style Checkpoint fill:#e1f0ff
```

#### Contract Agent

```mermaid
graph TB
    Start([Router에서]) --> LoadTask[작업 정보 로드]

    LoadTask --> LoadTemplate[계약서 템플릿 로드]

    LoadTemplate --> ExtractInfo[필요 정보 추출]

    ExtractInfo --> BuildPrompt[계약서 생성 Prompt]

    BuildPrompt --> CallLLM[LLM 호출<br/>GPT-4]

    CallLLM --> ParseContract[계약서 파싱]

    ParseContract --> Validate[유효성 검증]

    Validate --> SaveResult[결과 저장]

    SaveResult --> IncrementStep[current_step++]

    IncrementStep --> Checkpoint[Checkpoint 저장]

    Checkpoint --> End([Router로 복귀])

    style CallLLM fill:#ffe1e1
    style Checkpoint fill:#e1f0ff
```

---

### 5. Aggregator Node

**목적**: 모든 에이전트 결과를 통합하고 최종 응답 생성

```mermaid
graph TB
    Start([모든 단계 완료]) --> LoadResults[모든 결과 로드]

    LoadResults --> CheckFormat{output_format<br/>확인}

    CheckFormat -->|chat| ChatFormat[채팅 형식]
    CheckFormat -->|json| JSONFormat[JSON 형식]
    CheckFormat -->|markdown| MDFormat[Markdown 형식]

    ChatFormat --> BuildPrompt
    JSONFormat --> BuildPrompt
    MDFormat --> BuildPrompt

    BuildPrompt[Aggregation Prompt 구성] --> CallLLM[LLM 호출<br/>GPT-4]

    CallLLM --> ParseResponse[응답 파싱]

    ParseResponse --> FormatFinal[최종 형식화]

    FormatFinal --> SaveFinal[final_result 저장]

    SaveFinal --> SetComplete[is_executing: false]

    SetComplete --> Checkpoint[Checkpoint 저장]

    Checkpoint --> End([종료])

    style CallLLM fill:#ffe1e1
    style Checkpoint fill:#e1f0ff
    style End fill:#ffe1e1
```

**상태 업데이트**:
```python
{
    "final_result": "[최종 응답] 계약서 작성이 완료되었습니다...",
    "is_executing": False,
    "aggregated_data": {
        "summary": "...",
        "steps_completed": 3,
        "execution_time": "8분"
    }
}
```

---

## 에이전트 라우팅 로직

### 조건부 엣지 (Conditional Edge)

```mermaid
graph TB
    Router[Router Node] --> Condition{조건 평가}

    Condition -->|current_step < total_steps| NextAgent[다음 에이전트]
    Condition -->|current_step >= total_steps| Aggregator[Aggregator]

    NextAgent --> AgentType{에이전트 타입}

    AgentType -->|search| Search[Search Agent]
    AgentType -->|web| Web[Web Agent]
    AgentType -->|contract| Contract[Contract Agent]
    AgentType -->|code| Code[Code Agent]
    AgentType -->|data| Data[Data Agent]
    AgentType -->|hitl| HITL[HITL 처리]

    Search --> BackRouter[Router로 복귀]
    Web --> BackRouter
    Contract --> BackRouter
    Code --> BackRouter
    Data --> BackRouter
    HITL --> BackRouter

    BackRouter --> Router

    Aggregator --> End([종료])

    style Condition fill:#fff4e1
    style HITL fill:#ffe1e1
```

### 라우팅 구현 코드

```python
def should_continue(state: SupervisorState) -> str:
    """다음 노드 결정"""
    current_step = state.get("current_step", 0)
    plan = state.get("plan")

    if not plan:
        return END

    total_steps = plan.get("total_steps", 0)

    # 모든 단계 완료
    if current_step >= total_steps:
        return "aggregator"

    # 다음 단계 실행
    return "router"


def route_to_agent(state: SupervisorState) -> str:
    """에이전트 선택"""
    plan = state["plan"]
    current_step = state["current_step"]
    step_info = plan["steps"][current_step]
    agent = step_info["agent"]

    # HITL 체크
    if agent == "hitl" or step_info.get("requires_approval"):
        if not state.get("is_waiting_human"):
            interrupt("사용자 승인이 필요합니다")

    # 에이전트 매핑
    agent_map = {
        "search": "search_agent",
        "web": "web_agent",
        "contract": "contract_agent",
        "code": "code_agent",
        "data": "data_agent"
    }

    return agent_map.get(agent, "search_agent")
```

---

## 상태 전파

### StateGraph 상태 흐름

```mermaid
graph LR
    subgraph "초기 상태"
        S1[messages: 사용자 입력]
    end

    subgraph "Intent Node"
        S2[+ user_intent]
    end

    subgraph "Planning Node"
        S3[+ plan<br/>+ current_step: 0<br/>+ is_executing: true]
    end

    subgraph "Router Node"
        S4[상태 유지]
    end

    subgraph "Agent Node"
        S5[+ agent 결과<br/>+ current_step++]
    end

    subgraph "Aggregator Node"
        S6[+ final_result<br/>+ is_executing: false]
    end

    S1 --> S2 --> S3 --> S4 --> S5
    S5 -.->|더 많은 단계| S4
    S5 --> S6

    style S1 fill:#e1f5e1
    style S6 fill:#ffe1e1
```

### 상태 스키마

```python
class SupervisorState(TypedDict):
    # 메시지 히스토리
    messages: Annotated[list, add_messages]

    # 의도 분석 결과
    user_intent: Optional[dict]
    # {
    #     "category": "contract",
    #     "description": "...",
    #     "key_entities": [...],
    #     "complexity": "medium"
    # }

    # 실행 계획
    plan: Optional[dict]
    # {
    #     "total_steps": 3,
    #     "steps": [...]
    # }

    # 현재 단계
    current_step: int

    # 플래그
    is_planning: bool
    is_executing: bool
    is_waiting_human: bool  # HITL 대기

    # 결과 데이터
    aggregated_data: Optional[dict]
    final_result: Optional[str]

    # 출력 형식
    output_format: str  # "chat", "json", "markdown"
```

---

## 에이전트 간 통신

### 메시지 전달

```mermaid
sequenceDiagram
    participant User
    participant Intent
    participant Planning
    participant Router
    participant Agent
    participant Aggregator

    User->>Intent: HumanMessage
    Intent->>Intent: 의도 분석
    Intent->>Planning: + AIMessage (Intent)

    Planning->>Planning: 계획 수립
    Planning->>Router: + AIMessage (Plan)

    Router->>Router: 라우팅 결정
    Router->>Agent: State 전달

    Agent->>Agent: 작업 수행
    Agent->>Router: + AIMessage (Result)

    Router->>Router: 다음 단계 확인

    alt 더 많은 단계
        Router->>Agent: State 전달
    else 모든 단계 완료
        Router->>Aggregator: State 전달
    end

    Aggregator->>Aggregator: 결과 통합
    Aggregator->>User: + AIMessage (Final)
```

---

## 참조

- [시스템 아키텍처 명세서](./시스템_아키텍처_명세서_251103.md)
- [시스템 플로우차트](./시스템_플로우차트_251103.md)
- [API 명세서](./API_명세서_251103.md)
